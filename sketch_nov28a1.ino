/*
  УМНАЯ ТЕПЛИЦА - КОМПЛЕКСНАЯ СИСТЕМА АВТОМАТИЗАЦИИ
  С ФУНКЦИЕЙ АВТОМАТИЧЕСКОГО ВОССТАНОВЛЕНИЯ ДИСПЛЕЯ
*/

// ================================================
// РАЗДЕЛ 1: ПОДКЛЮЧЕНИЕ ВНЕШНИХ БИБЛИОТЕК
// ================================================

#include <Wire.h>                // Включаем библиотеку Wire для работы с I2C шиной
                                 // I2C - это протокол связи для подключения устройств по 2 проводам
                                 
#include <LiquidCrystal_I2C.h>   // Включаем библиотеку для LCD дисплея с I2C интерфейсом
                                 // Эта библиотека управляет текстом на дисплее 16x2
                                 
#include <DHT.h>                 // Включаем библиотеку для датчика температуры и влажности DHT22
                                 // Датчик DHT22 измеряет температуру и влажность воздуха
                                 
#include <Servo.h>               // Включаем библиотеку для управления сервоприводом
                                 // Сервопривод используется для открытия/закрытия форточки

// ================================================
// РАЗДЕЛ 2: УМНАЯ СИСТЕМА ЗАЩИТЫ ДИСПЛЕЯ
// ================================================

LiquidCrystal_I2C* lcd = NULL;   // Создаем УКАЗАТЕЛЬ на объект дисплея (не сам объект)
                                 // Указатель = адрес объекта в памяти компьютера
                                 // NULL означает "ничего не указывает" - объект еще не создан
                                 // Это нужно для восстановления дисплея
                                 
uint8_t lcdAddress = 0;          // Создаем переменную для хранения адреса дисплея на шине I2C
                                 // uint8_t = беззнаковое 8-битное число (0-255)
                                 // 0 означает "адрес еще не определен"
                                 
const uint8_t POSSIBLE_LCD_ADDRESSES[] = {0x27, 0x3F};  // Создаем массив возможных адресов дисплея
                                                        // Большинство дисплеев имеют адрес 0x27 или 0x3F
                                                        
const int NUM_POSSIBLE_ADDRESSES = 2;  // Создаем константу для количества возможных адресов
                                       // В массиве выше 2 адреса, поэтому значение = 2

// ================================================
// РАЗДЕЛ 3: СИСТЕМА ВОССТАНОВЛЕНИЯ ДИСПЛЕЯ
// ================================================

#define SUPER_PROTECTION true    // Определяем макрос для включения/выключения супер-защиты
                                 // true = защита ВКЛЮЧЕНА, false = защита ВЫКЛЮЧЕНА
                                 // Рекомендуется всегда держать включенной
                                 
enum DisplayMode {               // Создаем перечисление (enum) для состояний дисплея
                                 // Перечисление = список именованных значений
  DISPLAY_NORMAL,                // Значение 0: дисплей работает нормально
  DISPLAY_RECOVERING,            // Значение 1: пытаемся восстановить дисплей
  DISPLAY_DISCONNECTED           // Значение 2: дисплей отключен (сдались)
};

DisplayMode currentDisplayMode = DISPLAY_RECOVERING;  // Создаем переменную для текущего состояния дисплея
                                                      // Изначально устанавливаем в DISPLAY_RECOVERING
                                                      // Потому что при запуске нужно сначала найти дисплей
                                                      
int displayRecoveryAttempts = 0;           // Создаем переменную-счетчик попыток восстановления дисплея
                                           // Начальное значение = 0 (еще не пытались)
                                           
const int MAX_RECOVERY_ATTEMPTS = 10;      // Создаем константу для максимального количества попыток восстановления
                                           // Если после 10 попыток не получилось - сдаемся
                                           
unsigned long lastRecoveryAttempt = 0;     // Создаем переменную для хранения времени последней попытки восстановления
                                           // unsigned long = число от 0 до 4,294,967,295 (для времени)
                                           // Начальное значение = 0
                                           
const unsigned long RECOVERY_INTERVAL = 5000;  // Создаем константу для интервала между попытками восстановления
                                               // 5000 миллисекунд = 5 секунд
                                               // Не пытаемся восстанавливать слишком часто
                                               
unsigned long lastDisplaySuccess = 0;      // Создаем переменную для времени последней успешной работы дисплея
                                           // Используется для отслеживания, когда дисплей последний раз отвечал
                                           
bool forceDisplayReset = false;            // Создаем флаг (переключатель) для принудительного сброса дисплея
                                           // bool = логический тип (true/false)
                                           // true = нужно сделать принудительный сброс
                                           // false = не нужно

// ================================================
// РАЗДЕЛ 4: КОНФИГУРАЦИЯ ДАТЧИКОВ (ВКЛЮЧЕНИЕ/ОТКЛЮЧЕНИЕ)
// ================================================

#define ENABLE_DHT true         // Определяем макрос для включения/выключения датчика DHT22
                                 // true = датчик подключен и работает
                                 // false = датчик отключен (будут использоваться тестовые значения)
                                 
#define ENABLE_SOIL true         // Определяем макрос для включения/выключения датчика влажности почвы
                                 // true = датчик подключен
                                 // false = датчик отключен
                                 
#define ENABLE_LIGHT true        // Определяем макрос для включения/выключения датчика освещенности
                                 // true = датчик подключен (фоторезистор)
                                 // false = датчик отключен
                                 
#define ENABLE_WATER true        // Определяем макрос для включения/выключения датчика уровня воды
                                 // true = датчик подключен
                                 // false = датчик отключен
                                 // ОСОБЕННОСТЬ: Это БИНАРНЫЙ датчик (только 2 состояния)

// ================================================
// РАЗДЕЛ 5: ПОДКЛЮЧЕНИЕ УСТРОЙСТВ К ПИНАМ ARDUINO
// ================================================

// ----- ДАТЧИКИ (устройства ВВОДА - Arduino ЧИТАЕТ данные) -----
#define DHT_PIN 2               // Определяем пин для подключения датчика DHT11
                                 // DHT11 подключается к ЦИФРОВОМУ пину 2
                                 // Цифровой пин может передавать только 0 или 1 (LOW/HIGH)
#define DHTTYPE DHT11   // тип датчика  

#define SOIL_MOISTURE_PIN A0     // Определяем пин для подключения датчика влажности почвы
                                 // Датчик подключается к АНАЛОГОВОМУ пину A0
                                 // Аналоговый пин может измерять напряжение от 0 до 5В (значения 0-1023)
                                 
#define LIGHT_SENSOR_PIN A1      // Определяем пин для подключения датчика освещенности
                                 // Датчик подключается к АНАЛОГОВОМУ пину A1
                                 // Фоторезистор меняет сопротивление в зависимости от света
                                 
#define WATER_LEVEL_PIN A2       // Определяем пин для подключения датчика уровня воды
                                 // ОСОБЕННО ВАЖНО: Ваш датчик работает НАОБОРОТ!
                                 // Подключается к АНАЛОГОВОМУ пину A2
                                 // В воде: показывает HIGH (около 5В) → значение > 500
                                 // В воздухе: показывает LOW (около 0В) → значение < 500

// ----- ИСПОЛНИТЕЛЬНЫЕ УСТРОЙСТВА (устройства ВЫВОДА - Arduino УПРАВЛЯЕТ) -----
#define PUMP_PIN 3               // Определяем пин для управления НАСОСОМ
                                 // Подключается к ЦИФРОВОМУ пину 3
                                 // ВАЖНО: Насос подключается через РЕЛЕ (реле как выключатель)
                                 // HIGH на пине = насос ВКЛЮЧЕН, LOW = насос ВЫКЛЮЧЕН
                                 
#define SERVO_PIN 4              // Определяем пин для управления сервоприводом (форточкой)
                                 // Подключается к ЦИФРОВОМУ пину 4
                                 // Сервопривод получает сигнал о угле поворота (0-180 градусов)
                                 
#define LED_GROW_PIN 5           // Определяем пин для управления фитолентой
                                 // Подключается к ЦИФРОВОМУ пину 5
                                 // Фитолента подключается через РЕЛЕ
                                 // HIGH на пине = фитолента ВКЛЮЧЕНА, LOW = фитолента ВЫКЛЮЧЕНА
                                 
#define STATUS_LED 13            // Определяем пин для встроенного светодиода на плате Arduino
                                 // Это физический светодиод рядом с пином 13
                                 // Используется для индикации состояния системы

// ================================================
// РАЗДЕЛ 6: СОЗДАНИЕ ОБЪЕКТОВ ДЛЯ УПРАВЛЕНИЯ УСТРОЙСТВАМИ
// ================================================

DHT dht(DHT_PIN, DHT11);         // Создаем объект для датчика DHT11 с именем "dht"
                                 // Параметры конструктора: номер пина (DHT_PIN = 2), тип датчика (DHT22)
                                 // Объект - это экземпляр класса, который содержит методы для работы с датчиком
                                 
Servo ventServo;                 // Создаем объект для сервопривода с именем "ventServo"
                                 // Пока не привязан к конкретному пину
                                 // Привязка к пину будет выполнена в функции setup()

// ================================================
// РАЗДЕЛ 7: НАСТРОЙКИ СИСТЕМЫ (ПОРОГОВЫЕ ЗНАЧЕНИЯ)
// ================================================

// ----- ВРЕМЯ МЕЖДУ ПОЛИВАМИ -----
const unsigned long PUMP_RUN_TIME = 5000;          // 5 секунд работы насоса
const unsigned long WATERING_COOLDOWN = 300000;     // 300000 мс = 5 минут задержки между поливами

// ----- ВЛАЖНОСТЬ ПОЧВЫ (в процентах) -----
const int SOIL_DRY = 20;         // Порог СУХОЙ почвы (включаем полив)
const int SOIL_WET = 60;         // Порог ВЛАЖНОЙ почвы (в старом коде, теперь не используется для выключения)

// ----- ТЕМПЕРАТУРА ВОЗДУХА (в градусах Цельсия) -----
const float OPEN_TEMP = 28.0;    // Создаем константу для температуры ОТКРЫТИЯ форточки
                                 // Значение: 28.0 градусов Цельсия
                                 // float = число с плавающей точкой (дробное число)
                                 // ЕСЛИ температура > 28.0°C ТОГДА открыть форточку
                                 
const float CLOSE_TEMP = 26.0;   // Создаем константу для температуры ЗАКРЫТИЯ форточки
                                 // Значение: 26.0 градусов Цельсия
                                 // ЕСЛИ температура < 26.0°C ТОГДА закрыть форточку

// ----- ОСВЕЩЕННОСТЬ (в процентах) -----
const int LIGHT_ON_THRESHOLD = 30;   // Создаем константу для порога ВКЛЮЧЕНИЯ фитоленты
                                     // Значение: 30 процентов
                                     // ЕСЛИ освещенность < 30% ТОГДА включить фитоленту
                                     
const int LIGHT_OFF_THRESHOLD = 50;  // Создаем константу для порога ВЫКЛЮЧЕНИЯ фитоленты
                                     // Значение: 50 процентов
                                     // ЕСЛИ освещенность > 50% ТОГДА выключить фитоленту

// ----- НАСТРОЙКА БИНАРНОГО ДАТЧИКА ВОДЫ -----
const int WATER_SENSOR_THRESHOLD = 500;  // Создаем константу для ПОРОГА определения воды
                                         // Значение: 500 (из диапазона 0-1023)
                                         // Аналоговые значения от 0 до 1023
                                         // 500 - середина диапазона (2.5В)
                                         
const bool WATER_SENSOR_INVERTED = false; // Создаем константу для НАСТРОЙКИ ИНВЕРСИИ датчика воды
                                          // bool = логическое значение (true/false)
                                          // false = ваш датчик НЕинвертированный (работает НАОБОРОТ)
                                          // true = стандартный датчик инвертированный
                                          // ДЛЯ ВАШЕГО ДАТЧИКА ДОЛЖНО БЫТЬ false!

// ----- НАСТРОЙКИ СЕРВОПРИВОДА (углы в градусах) -----
const int SERVO_CLOSED = 0;          // Создаем константу для угла ЗАКРЫТОЙ форточки
                                     // Значение: 0 градусов
                                     // 0° = форточка полностью закрыта
                                     
const int SERVO_OPEN = 90;           // Создаем константу для угла ОТКРЫТОЙ форточки
                                     // Значение: 90 градусов
                                     // 90° = форточка полностью открыта

// ----- НАСТРОЙКА РЕЛЕ (для фитоленты и насоса) -----
const bool RELAY_INVERTED = true;    // Создаем константу для настройки РЕЖИМА РЕЛЕ
                                     // bool = логическое значение (true/false)
                                     // true = реле ИНВЕРТИРОВАННОЕ (LOW включает, HIGH выключает)
                                     // false = реле ОБЫЧНОЕ (HIGH включает, LOW выключает)
                                     // Большинство реле-модулей для Arduino инвертированные

// ----- КАЛИБРОВКА ДАТЧИКОВ -----
const int SOIL_DRY_CALIB = 620;      // Создаем константу для калибровки СУХОЙ почвы
                                     // Значение датчика в СУХОЙ почве = 620 (из 1023)
                                     // Это соответствует 0% влажности
                                     
const int SOIL_WET_CALIB = 310;      // Создаем константу для калибровки МОКРОЙ почвы
                                     // Значение датчика в МОКРОЙ почве = 310 (из 1023)
                                     // Это соответствует 100% влажности
                                     
const int DARK_VALUE = 0;            // Создаем константу для калибровки ТЕМНОТЫ
                                     // Значение датчика в ПОЛНОЙ ТЕМНОТЕ = 0 (из 1023)
                                     // Это соответствует 100% темноты (0% освещенности)
                                     
const int BRIGHT_VALUE = 675;        // Создаем константу для калибровки ЯРКОГО СВЕТА
                                     // Значение датчика при ЯРКОМ СВЕТЕ = 675 (из 1023)
                                     // Это соответствует 0% темноты (100% освещенности)

// ----- ДОПУСТИМЫЕ ПРЕДЕЛЫ ДЛЯ ПРОВЕРКИ ОШИБОК -----
const float MIN_TEMP = 0.0;      // DHT11 минимальная температура: 0°C
const float MAX_TEMP = 50.0;     // DHT11 максимальная температура: 50°C
const float MIN_HUMIDITY = 20.0; // DHT11 минимальная влажность: 20%
const float MAX_HUMIDITY = 80.0; // DHT11 максимальная влажность: 80%

// ----- НАСТРОЙКИ БЕЗОПАСНОСТИ НАСОСА -----
const unsigned long MAX_PUMP_RUN_TIME = 30000;  // Создаем константу для МАКСИМАЛЬНОГО времени работы насоса
                                                // Значение: 30000 миллисекунд = 30 секунд
                                                // Защита от перелива если датчик сломался
                                                // Насос не будет работать больше 30 секунд подряд
                                                
const unsigned long MIN_PUMP_OFF_TIME = 60000;  // Создаем константу для МИНИМАЛЬНОГО времени простоя насоса
                                                // Значение: 60000 миллисекунд = 60 секунд = 1 минута
                                                // Защита от частых включений/выключений
                                                // Насос не включится раньше чем через 1 минуту после выключения

// ================================================
// РАЗДЕЛ 8: ПЕРЕМЕННЫЕ ДЛЯ ХРАНЕНИЯ ДАННЫХ
// ================================================

// ----- ПЕРЕМЕННЫЕ ДЛЯ УМНОГО ЧТЕНИЯ ДАТЧИКА ВОДЫ -----
unsigned long lastWaterSensorRead = 0;              // Время последнего чтения датчика воды
const unsigned long WATER_SENSOR_COOLDOWN = 5000;   // Читаем датчик только раз в 5 секунд
bool lastWaterSensorValue = true;                   // Последнее известное значение

// ----- ТЕКУЩИЕ ПОКАЗАНИЯ ДАТЧИКОВ (с фильтрацией) -----
float tempFiltered = 25.0;           // Создаем переменную для хранения отфильтрованной температуры
                                     // float = число с плавающей точкой
                                     // Начальное значение: 25.0°C (комнатная температура)
                                     // Хранит текущую температуру после сглаживания фильтром
                                     
float humidityFiltered = 60.0;       // Создаем переменную для хранения отфильтрованной влажности воздуха
                                     // Начальное значение: 60.0% (нормальная влажность)
                                     // Хранит текущую влажность воздуха после сглаживания фильтром
                                     
int soilMoistureFiltered = 50;       // Создаем переменную для хранения отфильтрованной влажности почвы
                                     // int = целое число (integer)
                                     // Начальное значение: 50% (средняя влажность)
                                     // Хранит текущую влажность почвы после сглаживания фильтром
                                     
int lightLevelFiltered = 50;         // Создаем переменную для хранения отфильтрованной освещенности
                                     // Начальное значение: 50% (средняя освещенность)
                                     // Хранит текущую освещенность после сглаживания фильтром

// ----- ОСОБЕННОСТЬ: БИНАРНЫЙ ДАТЧИК ВОДЫ -----
bool waterPresent = false;           // Создаем переменную для хранения состояния датчика воды
                                     // bool = логическое значение (true/false)
                                     // true = вода ЕСТЬ в баке
                                     // false = воды НЕТ в баке
                                     // Начальное значение: false (считаем что воды нет)
                                     // ДЛЯ ВАШЕГО ДАТЧИКА: true когда значение > 500

// ----- КОЭФФИЦИЕНТ ФИЛЬТРАЦИИ -----
const float FILTER_COEFF = 0.7;      // Создаем константу для коэффициента фильтрации
                                     // Значение: 0.3 (30%)
                                     // Используется для сглаживания показаний датчиков
                                     // 0.3 = 30% нового значения + 70% старого значения
                                     // Убирает резкие скачки в показаниях

// ----- СОСТОЯНИЯ ИСПОЛНИТЕЛЬНЫХ УСТРОЙСТВ -----
bool pumpState = false;              // Создаем переменную для хранения состояния насоса
                                     // true = насос ВКЛЮЧЕН
                                     // false = насос ВЫКЛЮЧЕН
                                     // Начальное значение: false (насос выключен)
                                     
bool lampState = false;              // Создаем переменную для хранения состояния фитоленты
                                     // true = фитолента ВКЛЮЧЕНА
                                     // false = фитолента ВЫКЛЮЧЕНА
                                     // Начальное значение: false (фитолента выключена)
                                     
bool windowIsOpen = false;           // Создаем переменную для хранения состояния форточки
                                     // true = форточка ОТКРЫТА
                                     // false = форточка ЗАКРЫТА
                                     // Начальное значение: false (форточка закрыта)
                                     
int ventAngle = 0;                   // Создаем переменную для хранения текущего угла сервопривода
                                     // Начальное значение: 0° (форточка закрыта)
                                     // Может быть от 0° до 90°

// ----- ВРЕМЕННЫЕ ПЕРЕМЕННЫЕ (для контроля времени) -----
unsigned long lastWatering = 0;      // Создаем переменную для хранения времени последнего полива
                                     // unsigned long = большое целое число для времени
                                     // Хранит время в миллисекундах когда последний раз поливали
                                     // Начальное значение: 0
                                     
unsigned long pumpStartTime = 0;     // Создаем переменную для хранения времени включения насоса
                                     // Хранит время в миллисекундах когда включили насос
                                     // Используется для контроля времени работы насоса
                                     // Начальное значение: 0
                                     
const unsigned long WATERING_INTERVAL = 600000;  // Создаем константу для интервала полива
                                                 // Значение: 600000 миллисекунд = 600 секунд = 10 минут
                                                 // Минимальное время между поливами

// ----- УПРАВЛЕНИЕ ДИСПЛЕЕМ -----
int displayScreen = 0;               // Создаем переменную для номера текущего экрана дисплея
                                     // int = целое число
                                     // Начальное значение: 0 (первый экран)
                                     // 0 = температура и форточка
                                     // 1 = влажность воздуха
                                     // 2 = освещенность и фитолента
                                     // 3 = влажность почвы и насос
                                     // 4 = уровень воды
                                     
const int MAX_DISPLAY_SCREENS = 5;   // Создаем константу для максимального количества экранов
                                     // Значение: 5 (всего 5 экранов)
                                     // После 4-го экрана снова показывается 0-й
                                     
unsigned long lastDisplayChange = 0; // Создаем переменную для времени последней смены экрана
                                     // Хранит время в миллисекундах когда последний раз меняли экран
                                     // Начальное значение: 0
                                     
const int DISPLAY_CHANGE_TIME = 3000;// Создаем константу для времени смены экрана
                                     // Значение: 3000 миллисекунд = 3 секунды
                                     // Менять экран каждые 3 секунды

// ----- СЧЕТЧИК ОШИБОК ДАТЧИКА DHT -----
int dhtErrorCount = 0;               // Создаем переменную-счетчик ошибок датчика DHT
                                     // Считает сколько ошибок подряд произошло
                                     // Начальное значение: 0 (еще не было ошибок)
                                     
const int MAX_DHT_ERRORS = 10;       // Создаем константу для максимального количества ошибок DHT
                                     // Значение: 10
                                     // Если больше 10 ошибок подряд - серьезная проблема с датчиком

// ----- ПЕРЕМЕННЫЕ ДЛЯ КАЛИБРОВКИ ДАТЧИКА ВОДЫ -----
bool waterSensorCalibrationMode = false;  // Создаем переменную для режима калибровки датчика воды
                                          // true = включен режим калибровки
                                          // false = нормальный режим работы
                                          // Начальное значение: false
                                          
int waterSensorCalibrationCount = 0;      // Создаем переменную-счетчик измерений для калибровки
                                          // Считает сколько измерений сделано для усреднения
                                          // Начальное значение: 0
                                          
int waterSensorCalibrationSum = 0;        // Создаем переменную для суммы измерений для калибровки
                                          // Суммирует все измерения для вычисления среднего
                                          // Начальное значение: 0

// ================================================
// РАЗДЕЛ 9: ФУНКЦИИ ДЛЯ АВТОМАТИЧЕСКОГО ВОССТАНОВЛЕНИЯ ДИСПЛЕЯ
// ================================================

// ФУНКЦИЯ 1: ПОИСК ДИСПЛЕЯ НА ШИНЕ I2C
// Назначение: Найти дисплей на шине I2C по известным адресам
// Возвращает: true если дисплей найден, false если не найден
bool discoverLCD() {
  // Выводим сообщение в Serial монитор о начале поиска
  Serial.println("Поиск дисплея на шине I2C...");
  
  // Начинаем цикл for для перебора всех возможных адресов дисплея
  // i = счетчик цикла, начинается с 0, увеличивается на 1 каждый раз
  // Условие: i < NUM_POSSIBLE_ADDRESSES (2)
  // Цикл выполнится 2 раза: для i=0 и i=1
  for (int i = 0; i < NUM_POSSIBLE_ADDRESSES; i++) {
    
    // Берем очередной адрес из массива POSSIBLE_LCD_ADDRESSES
    // POSSIBLE_LCD_ADDRESSES[0] = 0x27, POSSIBLE_LCD_ADDRESSES[1] = 0x3F
    uint8_t address = POSSIBLE_LCD_ADDRESSES[i];
    
    // Выводим информацию о проверяемом адресе в Serial монитор
    Serial.print("Пробую адрес 0x");
    Serial.print(address, HEX);  // Выводим адрес в шестнадцатеричном формате
    Serial.print("... ");
    
    // Начинаем передачу на указанный адрес по шине I2C
    Wire.beginTransmission(address);
    
    // Завершаем передачу и получаем код ошибки
    // error = 0: успешно (устройство ответило)
    // error > 0: ошибка (устройство не ответило)
    byte error = Wire.endTransmission();
    
    // Проверяем, есть ли ошибка
    if (error == 0) {
      // Если ошибки нет (код 0) - дисплей найден!
      Serial.println("НАШЕЛ!");
      
      // Сохраняем найденный адрес в переменную lcdAddress
      lcdAddress = address;
      
      // Возвращаем true (успех) из функции
      return true;
      
    } else {
      // Если есть ошибка - на этом адресе никого нет
      Serial.println("нет ответа");
    }
    
    // Делаем короткую паузу 10 мс между попытками
    delay(10);
  }
  
  // Если дошли до этой точки - ни на одном адресе не нашли дисплей
  Serial.println("Дисплей не найден на шине I2C");
  
  // Возвращаем false (неудача) из функции
  return false;
}

// ФУНКЦИЯ 2: ИНИЦИАЛИЗАЦИЯ ДИСПЛЕЯ
// Назначение: Создать и настроить объект дисплея
// Возвращает: true если инициализация успешна, false если нет
bool initializeLCD() {
  // ШАГ 1: Проверяем, существует ли уже объект дисплея
  if (lcd != NULL) {
    // Если объект существует (указатель не равен NULL)
    // Удаляем старый объект из памяти с помощью оператора delete
    delete lcd;
    
    // Устанавливаем указатель в NULL (теперь он ничего не указывает)
    lcd = NULL;
    
    // Ждем 100 мс чтобы память полностью освободилась
    delay(100);
  }
  
  // ШАГ 2: Пытаемся найти дисплей на шине I2C
  if (!discoverLCD()) {
    // Если не нашли дисплей (! означает "НЕ", так что !discoverLCD() = true если discoverLCD() вернул false)
    // Возвращаем false - инициализация не удалась
    return false;
  }
  
  // ШАГ 3: Создаем новый объект дисплея
  // Оператор new выделяет память и создает объект класса LiquidCrystal_I2C
  // Параметры конструктора: адрес дисплея (lcdAddress), 16 столбцов, 2 строки
  lcd = new LiquidCrystal_I2C(lcdAddress, 16, 2);
  
  // ШАГ 4: Настраиваем дисплей
  // Вызываем метод init() у объекта дисплея для инициализации
  lcd->init();
  
  // Ждем 100 мс пока дисплей инициализируется
  delay(100);
  
  // Включаем подсветку дисплея с помощью метода backlight()
  lcd->backlight();
  
  // Ждем 50 мс
  delay(50);
  
  // ШАГ 5: Показываем тестовое сообщение
  // Очищаем экран дисплея с помощью метода clear()
  lcd->clear();
  
  // Устанавливаем курсор в позицию: столбец 0, строка 0
  // setCursor(колонка, строка) - колонка от 0 до 15, строка от 0 до 1
  lcd->setCursor(0, 0);
  
  // Печатаем текст "LCD Found!" (только английские буквы!)
  lcd->print("LCD Found!");
  
  // Переходим на вторую строку: столбец 0, строка 1
  lcd->setCursor(0, 1);
  
  // Печатаем текст "Addr: 0x"
  lcd->print("Addr: 0x");
  
  // Печатаем адрес дисплея в шестнадцатеричном формате
  lcd->print(lcdAddress, HEX);
  
  // Показываем сообщение 1 секунду (1000 мс)
  delay(1000);
  
  // Выводим информацию в Serial монитор
  Serial.print("Дисплей инициализирован на адресе 0x");
  Serial.println(lcdAddress, HEX);
  
  // Возвращаем true - инициализация успешна
  return true;
}

// ФУНКЦИЯ 3: ПРОВЕРКА ЗДОРОВЬЯ ДИСПЛЕЯ
// Назначение: Проверить, отвечает ли дисплей на команды
// Возвращает: true если дисплей здоров, false если нет
bool checkLCDHealth() {
  // Проверяем, существует ли объект дисплея (указатель не равен NULL)
  if (lcd == NULL) {
    // Если объекта нет - возвращаем false (дисплей не инициализирован)
    return false;
  }
  
  // Проверяем, включена ли супер-защита (макрос SUPER_PROTECTION)
  #if SUPER_PROTECTION
  // Если супер-защита включена (SUPER_PROTECTION = true)
  
  // Пытаемся выполнить простую операцию с дисплеем
  // Выключаем отображение (не подсветку!) с помощью метода noDisplay()
  lcd->noDisplay();
  
  // Ждем 10 мс
  delay(10);
  
  // Включаем отображение обратно с помощью метода display()
  lcd->display();
  
  // Ждем 10 мс
  delay(10);
  
  // Если выполнение дошло до этой точки без зависания - дисплей работает
  // Обновляем время последней успешной работы
  lastDisplaySuccess = millis();
  
  // Возвращаем true - дисплей здоров
  return true;
  
  #else
  // Если защита отключена (SUPER_PROTECTION = false)
  // Всегда считаем что дисплей работает
  return true;
  #endif
}

// ФУНКЦИЯ 4: БЕЗОПАСНАЯ ПЕЧАТЬ НА ДИСПЛЕЙ
// Назначение: Напечатать текст на дисплее безопасным способом
// Параметры:
//   text - текст для печати (только английский!)
//   col - столбец (0-15)
//   row - строка (0-1)
// Возвращает: true если печать успешна, false если нет
bool safePrint(const char* text, uint8_t col, uint8_t row) {
  // ПРОВЕРКА 1: Существует ли объект дисплея?
  if (lcd == NULL) {
    // Нет объекта - не можем печатать, возвращаем false
    return false;
  }
  
  // ПРОВЕРКА 2: Дисплей в нормальном режиме?
  if (currentDisplayMode != DISPLAY_NORMAL) {
    // Дисплей не в нормальном режиме - не печатаем, возвращаем false
    return false;
  }
  
  // Проверяем, включена ли супер-защита
  #if SUPER_PROTECTION
  // Если супер-защита включена
  
  // Просто пытаемся напечатать
  // Устанавливаем курсор в указанную позицию
  lcd->setCursor(col, row);
  
  // Печатаем текст
  lcd->print(text);
  
  // Обновляем время последней успешной работы
  lastDisplaySuccess = millis();
  
  // Возвращаем true - успешно напечатали
  return true;
  
  #else
  // Если защита отключена
  
  // Просто печатаем без проверок
  lcd->setCursor(col, row);
  lcd->print(text);
  
  // Возвращаем true
  return true;
  #endif
}

// ФУНКЦИЯ 5: ПОПЫТКА ВОССТАНОВЛЕНИЯ ДИСПЛЕЯ
// Назначение: Попытаться восстановить работу дисплея после сбоя
// Возвращает: true если восстановление успешно, false если нет
bool attemptDisplayRecovery() {
  // Получаем текущее время в миллисекундах с помощью функции millis()
  unsigned long currentTime = millis();
  
  // Проверяем, можно ли пытаться восстановить сейчас
  // Вычисляем разницу между текущим временем и временем последней попытки
  // Если разница меньше RECOVERY_INTERVAL (5 секунд) - еще рано пытаться
  if (currentTime - lastRecoveryAttempt < RECOVERY_INTERVAL) {
    // Возвращаем false - еще рано пытаться
    return false;
  }
  
  // Начинаем попытку восстановления
  Serial.println("Пытаюсь восстановить дисплей...");
  
  // Запоминаем время этой попытки
  lastRecoveryAttempt = currentTime;
  
  // Увеличиваем счетчик попыток на 1
  displayRecoveryAttempts++;
  
  // МЕТОД 1: МЯГКИЙ СБРОС (самый простой)
  // Проверяем, существует ли объект дисплея
  if (lcd != NULL) {
    Serial.println("Метод 1: Мягкий сброс");
    
    // Выключаем подсветку дисплея
    lcd->noBacklight();
    
    // Ждем 200 мс
    delay(200);
    
    // Включаем подсветку обратно
    lcd->backlight();
    
    // Ждем 200 мс
    delay(200);
    
    // Проверяем, помогло ли
    if (checkLCDHealth()) {
      // Если помогло - вызываем функцию успешного восстановления
      recoverySuccess();
      
      // Возвращаем true - восстановление успешно
      return true;
    }
  }
  
  // МЕТОД 2: ПЕРЕИНИЦИАЛИЗАЦИЯ
  Serial.println("Метод 2: Переинициализация");
  
  // Пробуем создать дисплей заново с помощью функции initializeLCD()
  if (initializeLCD()) {
    // Проверяем, работает ли теперь дисплей
    if (checkLCDHealth()) {
      // Если работает - вызываем функцию успешного восстановления
      recoverySuccess();
      
      // Возвращаем true - восстановление успешно
      return true;
    }
  }
  
  // МЕТОД 3: ПОЛНЫЙ СБРОС I2C ШИНЫ
  // Делаем только после 3-х неудачных попыток
  if (displayRecoveryAttempts >= 3) {
    Serial.println("Метод 3: Полный сброс I2C шины");
    
    // Отключаем всю шину I2C с помощью функции Wire.end()
    Wire.end();
    
    // Ждем 100 мс
    delay(100);
    
    // Включаем шину I2C заново с помощью функции Wire.begin()
    Wire.begin();
    
    // Ждем 100 мс
    delay(100);
    
    // Пробуем инициализировать дисплей после сброса шины
    // && означает "И" - оба условия должны быть true
    if (initializeLCD() && checkLCDHealth()) {
      // Если работает - вызываем функцию успешного восстановления
      recoverySuccess();
      
      // Возвращаем true - восстановление успешно
      return true;
    }
  }
  
  // Если сделали 10 попыток и все неудачные
  if (displayRecoveryAttempts >= MAX_RECOVERY_ATTEMPTS) {
    Serial.println("Слишком много неудачных попыток. Сдаюсь.");
    
    // Переходим в режим "отключен"
    currentDisplayMode = DISPLAY_DISCONNECTED;
  }
  
  // Возвращаем false - восстановление не удалось
  return false;
}

// ФУНКЦИЯ 6: ОБРАБОТКА УСПЕШНОГО ВОССТАНОВЛЕНИЯ
// Назначение: Выполнить действия после успешного восстановления дисплея
void recoverySuccess() {
  // Выводим сообщение в Serial монитор
  Serial.println("Дисплей успешно восстановлен!");
  
  // Сбрасываем счетчик попыток восстановления в 0
  displayRecoveryAttempts = 0;
  
  // Переходим в нормальный режим
  currentDisplayMode = DISPLAY_NORMAL;
  
  // Обновляем время последней успешной работы
  lastDisplaySuccess = millis();
  
  // Возвращаемся к первому экрану
  displayScreen = 0;
  
  // Сбрасываем таймер смены экрана
  lastDisplayChange = millis();
  
  // Показываем сообщение о восстановлении на дисплее
  lcd->clear();
  lcd->setCursor(0, 0);
  lcd->print("Recovered!");     // "Восстановлено!"
  lcd->setCursor(0, 1);
  lcd->print("Resuming...");    // "Продолжаю..."
  
  // Показываем сообщение 1.5 секунды
  delay(1500);
}

// ================================================
// РАЗДЕЛ 10: ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ================================================

// ФУНКЦИЯ 7: ФИЛЬТР СГЛАЖИВАНИЯ ЗНАЧЕНИЙ
// Назначение: Убирает резкие скачки в показаниях датчиков
// Параметры:
//   oldValue - предыдущее отфильтрованное значение
//   newValue - новое "сырое" значение с датчика  
//   coeff - коэффициент фильтрации (0.0 - 1.0)
// Возвращает: новое отфильтрованное значение
float applyFilter(float oldValue, float newValue, float coeff) {
  // Применяем формулу экспоненциального сглаживания:
  // новое_значение = старое_значение * (1 - коэффициент) + новое_значение * коэффициент
  // Пример: если коэффициент = 0.3, то 30% нового значения, 70% старого
  return oldValue * (1 - coeff) + newValue * coeff;  // Возвращаем сглаженное значение
}

// ФУНКЦИЯ 8: ТОЧНОЕ ИЗМЕРЕНИЕ ВЛАЖНОСТИ ПОЧВЫ
// Назначение: Получаем стабильные показания датчика почвы
// Возвращает: усредненное "сырое" значение (0-1023)
int readSoilMoistureStable() {
  // Проверяем, включен ли датчик влажности почвы в настройках (макрос ENABLE_SOIL)
  #if ENABLE_SOIL  // Если ENABLE_SOIL определен как true
  
  const int NUM_READINGS = 10;  // Количество измерений для усреднения
  int readings[NUM_READINGS];   // Массив для хранения измерений
  
  // Цикл для сбора измерений с датчика
  for (int i = 0; i < NUM_READINGS; i++) {  // Повторяем NUM_READINGS раз
    readings[i] = analogRead(SOIL_MOISTURE_PIN);  // Читаем значение с аналогового пина
    delay(2);  // Короткая пауза для стабилизации датчика
  }
  
  // СОРТИРОВКА измерений по возрастанию (пузырьковая сортировка)
  // Это нужно чтобы исключить выбросы (очень большие или очень маленькие значения)
  for (int i = 0; i < NUM_READINGS-1; i++) {  // Проходим по всем элементам кроме последнего
    for (int j = i+1; j < NUM_READINGS; j++) {  // Сравниваем текущий элемент со всеми следующими
      if (readings[i] > readings[j]) {  // Если текущий элемент больше следующего
        int temp = readings[i];      // Сохраняем текущий элемент во временную переменную
        readings[i] = readings[j];   // Меняем местами - меньший становится раньше
        readings[j] = temp;          // Больший становится позже
      }
    }
  }
  
  // Суммируем средние значения, исключая 2 самых маленьких и 2 самых больших
  // Это убирает возможные выбросы (ошибки измерений)
  int sum = 0;  // Переменная для хранения суммы
  for (int i = 2; i < NUM_READINGS-2; i++) {  // Начинаем с 3-го элемента, заканчиваем предпоследним 3-им
    sum += readings[i];  // Добавляем значение к сумме
  }
  
  // Возвращаем среднее значение (сумма / количество)
  return sum / (NUM_READINGS - 4);  // Вычитаем 4 потому что исключили 4 значения (2 минимальных + 2 максимальных)
  
  #else  // Если ENABLE_SOIL определен как false (датчик отключен)
  
  return 512;  // Возвращаем среднее значение 512 (середина диапазона 0-1023)
  
  #endif  // Конец условия #if ENABLE_SOIL
}

// ФУНКЦИЯ 9: ЧТЕНИЕ АНАЛОГОВОГО ДАТЧИКА С УСРЕДНЕНИЕМ
// Универсальная функция для любого аналогового датчика
// Параметр: pin - номер аналогового пина для чтения
// Возвращает: усредненное значение (0-1023)
int readAnalogSensorStable(int pin) {
  const int NUM_READINGS = 10;  // Количество измерений
  int readings[NUM_READINGS];   // Массив для хранения
  
  // Собираем измерения с указанного пина
  for (int i = 0; i < NUM_READINGS; i++) {  // Цикл по всем измерениям
    readings[i] = analogRead(pin);  // Читаем значение с указанного пина
    delay(2);  // Короткая пауза
  }
  
  // СОРТИРОВКА измерений по возрастанию (пузырьковая сортировка)
  for (int i = 0; i < NUM_READINGS-1; i++) {  // Внешний цикл
    for (int j = i+1; j < NUM_READINGS; j++) {  // Внутренний цикл
      if (readings[i] > readings[j]) {  // Если нужно поменять местами
        int temp = readings[i];      // Сохраняем во временную переменную
        readings[i] = readings[j];   // Меняем местами
        readings[j] = temp;          // Завершаем обмен
      }
    }
  }
  
  // Суммируем средние значения (исключаем крайние)
  int sum = 0;  // Инициализируем сумму
  for (int i = 2; i < NUM_READINGS-2; i++) {  // Цикл по средним значениям
    sum += readings[i];  // Добавляем к сумме
  }
  
  // Возвращаем среднее арифметическое
  return sum / (NUM_READINGS - 4);  // Делим сумму на количество оставшихся значений
}

// ФУНКЦИЯ 10: ЧТЕНИЕ БИНАРНОГО ДАТЧИКА ВОДЫ (СТАРАЯ ВЕРСИЯ)
// Назначение: Определить, есть ли вода в баке
// Возвращает: true если вода есть, false если воды нет
bool readBinaryWaterSensor() {
  // Проверяем, включен ли датчик воды в настройках
  #if ENABLE_WATER  // Если ENABLE_WATER = true
  
  // Если включен режим калибровки датчика воды
  if (waterSensorCalibrationMode) {  // Проверяем флаг калибровки
    waterSensorCalibrationSum += analogRead(WATER_LEVEL_PIN);  // Добавляем текущее чтение к сумме
    waterSensorCalibrationCount++;  // Увеличиваем счетчик измерений
    
    // Проверяем, набрали ли достаточно измерений (100)
    if (waterSensorCalibrationCount >= 100) {  // Если сделали 100 измерений
      int average = waterSensorCalibrationSum / waterSensorCalibrationCount;  // Вычисляем среднее
      Serial.print("Калибровка датчика воды: среднее значение = ");  // Выводим сообщение
      Serial.println(average);  // Выводим среднее значение
      
      // Сбрасываем переменные калибровки
      waterSensorCalibrationMode = false;  // Выключаем режим калибровки
      waterSensorCalibrationSum = 0;       // Обнуляем сумму
      waterSensorCalibrationCount = 0;     // Обнуляем счетчик
    }
    
    return true;  // В режиме калибровки всегда возвращаем true (вода есть)
  }
  
  // НОРМАЛЬНЫЙ РЕЖИМ РАБОТЫ (не калибровка)
  const int NUM_READINGS = 5;  // Количество измерений для усреднения
  int sum = 0;  // Переменная для суммы измерений
  
  // Делаем несколько измерений для надежности
  for (int i = 0; i < NUM_READINGS; i++) {  // Цикл по всем измерениям
    sum += analogRead(WATER_LEVEL_PIN);  // Читаем значение и добавляем к сумме
    delay(2);  // Короткая пауза между измерениями
  }
  
  int averageValue = sum / NUM_READINGS;  // Вычисляем среднее значение
  
  // Определяем наличие воды в зависимости от типа датчика
  if (WATER_SENSOR_INVERTED) {  // Если датчик ИНВЕРТИРОВАННЫЙ (стандартный)
    // Стандартный датчик: LOW в воде, HIGH в воздухе
    // Порог 500: если значение < 500 → вода есть
    return (averageValue < WATER_SENSOR_THRESHOLD);  // Возвращаем true если значение ниже порога
  } else {  // Если датчик НЕинвертированный (ВАШ датчик)
    // Ваш датчик: HIGH в воде, LOW в воздухе
    // Порог 500: если значение > 500 → вода есть
    return (averageValue > WATER_SENSOR_THRESHOLD);  // Возвращаем true если значение выше порога
  }
  
  #else  // Если ENABLE_WATER = false (датчик отключен)
  
  return true;  // Возвращаем true (считаем что вода есть для тестирования)
  
  #endif  // Конец условия #if ENABLE_WATER
}

// ФУНКЦИЯ 11: УМНОЕ ЧТЕНИЕ ДАТЧИКА ВОДЫ С ЗАЩИТОЙ ОТ КОРРОЗИИ
// Назначение: Читать датчик воды редко, чтобы предотвратить коррозию контактов
// Возвращает: true если вода есть, false если воды нет
bool readWaterSensorProtected() {
  // Получаем текущее время в миллисекундах
  unsigned long currentTime = millis();  // Функция millis() возвращает время с начала работы
  
  // Проверяем, можно ли читать датчик (читаем только раз в 5 секунд)
  if (currentTime - lastWaterSensorRead < WATER_SENSOR_COOLDOWN) {  // Если еще не прошло 5 секунд
    // Возвращаем последнее известное значение (не трогаем датчик)
    return lastWaterSensorValue;  // Это уменьшает коррозию
  }
  
  // Обновляем время последнего чтения
  lastWaterSensorRead = currentTime;  // Запоминаем, когда читали датчик в последний раз
  
  // Проверяем, включен ли датчик воды в настройках
  #if ENABLE_WATER  // Если датчик включен
  
  // КОРОТКОЕ И БЫСТРОЕ ЧТЕНИЕ (минимизируем время контакта с водой)
  const int NUM_READINGS = 3;  // Всего 3 измерения вместо 5 (быстрее!)
  int sum = 0;  // Переменная для суммы
  
  // Быстро делаем несколько измерений
  for (int i = 0; i < NUM_READINGS; i++) {  // Цикл по измерениям
    sum += analogRead(WATER_LEVEL_PIN);  // Читаем значение с датчика
    delay(1);  // Минимальная задержка (1 мс вместо 2 мс)
  }
  
  // Вычисляем среднее значение
  int averageValue = sum / NUM_READINGS;  // Делим сумму на количество
  
  // Определяем наличие воды по логике датчика
  if (WATER_SENSOR_INVERTED) {  // Если датчик инвертированный
    // Для стандартного датчика (инвертированного)
    // LOW в воде → значение < порога
    lastWaterSensorValue = (averageValue < WATER_SENSOR_THRESHOLD);  // Сохраняем результат
  } else {  // Если датчик НЕинвертированный
    // Для ВАШЕГО датчика (работает наоборот)
    // HIGH в воде → значение > порога
    lastWaterSensorValue = (averageValue > WATER_SENSOR_THRESHOLD);  // Сохраняем результат
  }
  
  // Отладочный вывод в Serial монитор (раз в 10 секунд, чтобы не засорять вывод)
  static unsigned long lastDebugOutput = 0;  // Время последнего вывода (static сохраняет значение между вызовами)
  if (currentTime - lastDebugOutput > 10000) {  // Если прошло больше 10 секунд
    lastDebugOutput = currentTime;  // Обновляем время последнего вывода
    
    // Выводим информацию о датчике
    Serial.print("Water sensor: raw=");  // Сырое значение
    Serial.print(averageValue);         // Выводим значение
    Serial.print(" (threshold=");       // Пороговое значение
    Serial.print(WATER_SENSOR_THRESHOLD);  // Выводим порог
    Serial.print("), water=");          // Наличие воды
    Serial.println(lastWaterSensorValue ? "YES" : "NO");  // Условный оператор: если true то "YES", иначе "NO"
    
    // Дополнительная информация о логике датчика
    Serial.print("  Sensor logic: ");  // Логика работы
    if (WATER_SENSOR_INVERTED) {  // Проверяем тип датчика
      Serial.println("INVERTED (LOW in water)");  // Стандартный датчик
    } else {
      Serial.println("YOUR SENSOR (HIGH in water)");  // Ваш датчик (работает наоборот)
    }
  }
  
  // Возвращаем новое значение
  return lastWaterSensorValue;  // Возвращаем результат
  
  #else  // Если датчик отключен в настройках (ENABLE_WATER = false)
  
  lastWaterSensorValue = true;  // Считаем что вода есть (для тестирования)
  return lastWaterSensorValue;  // Возвращаем true
  
  #endif  // Конец условия #if ENABLE_WATER
}



// ================================================
// РАЗДЕЛ 11: ФУНКЦИЯ НАЧАЛЬНОЙ НАСТРОЙКИ (SETUP)
// ================================================

// Функция setup() выполняется ОДИН РАЗ при включении Arduino
void setup() {
  // ----- ШАГ 0: ДЛИННАЯ ПАУЗА ДЛЯ СТАБИЛИЗАЦИИ -----
  // ОЧЕНЬ ВАЖНО: Ждем 3 секунды чтобы все устройства "проснулись"
  // Многие проблемы с дисплеем решаются этой длинной паузой
  delay(3000);  // 3000 миллисекунд = 3 секунды
  
  // ----- ШАГ 1: НАСТРОЙКА СЕРИАЛЬНОГО ПОРТА -----
  // Открываем Serial порт со скоростью 9600 бит в секунду
  // Serial порт нужен для отладки - вывода информации в монитор порта
  Serial.begin(9600);
  
  // Выводим приветственное сообщение в Serial монитор
  Serial.println("=== SMART GREENHOUSE STARTED ===");
  Serial.println("System initialization...");
  
  // ----- ШАГ 2: НАСТРОЙКА ШИНЫ I2C -----
  // Инициализируем библиотеку Wire для работы с шиной I2C
  // I2C нужен для связи с LCD дисплеем
  Wire.begin();
  
  // Ждем 100 мс для стабилизации шины I2C
  delay(100);
  
  // ----- ШАГ 3: НАСТРОЙКА ВСТРОЕННОГО СВЕТОДИОДА -----
  // Устанавливаем пин STATUS_LED (13) как ВЫХОД
  // OUTPUT значит Arduino будет подавать напряжение на этот пин
  pinMode(STATUS_LED, OUTPUT);
  
  // Выключаем светодиод (LOW = 0В = выключен)
  digitalWrite(STATUS_LED, LOW);
  
  // Мигаем светодиодом 3 раза для проверки
  for (int i = 0; i < 3; i++) {
    digitalWrite(STATUS_LED, HIGH);  // Включаем (HIGH = 5В)
    delay(200);                      // Ждем 200 мс (0.2 секунды)
    digitalWrite(STATUS_LED, LOW);   // Выключаем
    delay(200);                      // Ждем 200 мс
  }
  
  // ----- ШАГ 4: ПОПЫТКА НАЙТИ И НАСТРОИТЬ ДИСПЛЕЙ -----
  Serial.println("\nИщу дисплей...");
  
  // Пытаемся инициализировать дисплей с помощью функции initializeLCD()
  if (initializeLCD()) {
    // Если успешно - переходим в нормальный режим
    currentDisplayMode = DISPLAY_NORMAL;
    Serial.println("Дисплей найден и настроен");
  } else {
    // Если не нашли - будем пытаться в основном цикле
    currentDisplayMode = DISPLAY_RECOVERING;
    Serial.println("Дисплей не найден, буду пытаться в основном цикле");
  }
  
  // ----- ШАГ 5: НАСТРОЙКА ДАТЧИКА DHT11 -----
  // Вызываем метод begin() у объекта dht для инициализации датчика
  dht.begin();
  // Проверяем, включен ли датчик DHT в настройках
  #if ENABLE_DHT
  #endif
  
  // ----- ШАГ 6: НАСТРОЙКА ПИНОВ КАК ВЫХОДОВ -----
  // Устанавливаем пин насоса (PUMP_PIN = 3) как ВЫХОД
  // Arduino будет управлять насосом через этот пин
  pinMode(PUMP_PIN, OUTPUT);
  
  // Устанавливаем пин фитоленты (LED_GROW_PIN = 5) как ВЫХОД
  pinMode(LED_GROW_PIN, OUTPUT);
  
  // Устанавливаем пин светодиода (STATUS_LED = 13) как ВЫХОД
  // Уже настраивали, но для надежности еще раз
  pinMode(STATUS_LED, OUTPUT);
  
  // ----- ШАГ 7: УСТАНОВКА НАЧАЛЬНОГО СОСТОЯНИЯ -----
  // При запуске все устройства должны быть выключены
  
  // НАСОС: устанавливаем начальное состояние ВЫКЛЮЧЕН
  // Для управления насосом используем digitalWrite()
  // LOW = 0В = насос ВЫКЛЮЧЕН
  digitalWrite(PUMP_PIN, LOW);
  
  // ФИТОЛЕНТА: учитываем тип реле
  // Проверяем, инвертированное ли реле
  if (RELAY_INVERTED) {
    // Для инвертированного реле: HIGH = ВЫКЛ
    digitalWrite(LED_GROW_PIN, HIGH);
  } else {
    // Для обычного реле: LOW = ВЫКЛ
    digitalWrite(LED_GROW_PIN, LOW);
  }
  
  // Светодиод ВЫКЛЮЧЕН
  digitalWrite(STATUS_LED, LOW);
  
  // ----- ШАГ 8: НАСТРОЙКА СЕРВОПРИВОДА -----
  // Подключаем сервопривод к указанному пину (SERVO_PIN = 4)
  ventServo.attach(SERVO_PIN);
  
  // Устанавливаем начальное положение: ЗАКРЫТО (0°)
  ventServo.write(SERVO_CLOSED);
  
  // Пауза 500 мс для поворота сервопривода
  delay(500);
  
  // ----- ШАГ 9: НАСТРОЙКА АНАЛОГОВЫХ ВХОДОВ -----
  // Устанавливаем стандартное опорное напряжение 5В для аналоговых входов
  analogReference(DEFAULT);
  
  // Пауза 100 мс для стабилизации
  delay(100);
  
  // ----- ШАГ 10: ВЫВОД ИНФОРМАЦИИ О НАСТРОЙКАХ -----
  Serial.println("\n=== SYSTEM SETTINGS ===");
  
  // Выводим пороговые значения в Serial монитор
  Serial.print("Water plants when soil < ");
  Serial.print(SOIL_DRY);
  Serial.println("%");
  
  Serial.print("Open window when temperature > ");
  Serial.print(OPEN_TEMP);
  Serial.println("C");
  
  Serial.print("Turn on grow light when light < ");
  Serial.print(LIGHT_ON_THRESHOLD);
  Serial.println("%");
  
  // Выводим информацию о датчике воды
  Serial.print("Water sensor inverted: ");
  // Используем тернарный оператор для вывода текста
  Serial.println(WATER_SENSOR_INVERTED ? "YES (standard)" : "NO (your sensor)");
  
  // Выводим информацию о реле
  Serial.print("Relay inverted: ");
  Serial.println(RELAY_INVERTED ? "YES (LOW=ON)" : "NO (HIGH=ON)");
  
  // ----- ШАГ 11: ТЕСТИРОВАНИЕ РЕЛЕ ДЛЯ ФИТОЛЕНТЫ -----
  Serial.println("\nTesting grow light relay...");
  
  // ВКЛЮЧАЕМ фитоленту для теста
  if (RELAY_INVERTED) {
    // Для инвертированного реле: LOW = ВКЛ
    digitalWrite(LED_GROW_PIN, LOW);
  } else {
    // Для обычного реле: HIGH = ВКЛ
    digitalWrite(LED_GROW_PIN, HIGH);
  }
  
  // Держим включенной 1 секунду
  delay(1000);
  
  // ВЫКЛЮЧАЕМ фитоленту
  if (RELAY_INVERTED) {
    // Для инвертированного реле: HIGH = ВЫКЛ
    digitalWrite(LED_GROW_PIN, HIGH);
  } else {
    // Для обычного реле: LOW = ВЫКЛ
    digitalWrite(LED_GROW_PIN, LOW);
  }
  
  // Пауза 1 секунда
  delay(1000);
  
  // ----- ШАГ 12: ВЫВОД СТАТУСА ВСЕХ ДАТЧИКОВ -----
  Serial.println("\n=== SENSOR STATUS ===");
  
  // Выводим статус датчика DHT
  #if ENABLE_DHT
  Serial.println("DHT22 temperature/humidity sensor: ENABLED");
  #endif
  
  // Выводим статус датчика почвы
  #if ENABLE_SOIL
  Serial.println("Soil moisture sensor: ENABLED");
  #endif
  
  // Выводим статус датчика освещенности
  #if ENABLE_LIGHT
  Serial.println("Light sensor: ENABLED");
  #endif
  
  // Выводим статус датчика воды
  #if ENABLE_WATER
  Serial.println("Water level sensor: ENABLED (BINARY, INVERTED LOGIC)");
  #endif
  
  // ----- ШАГ 13: ПОКАЗ ПРИВЕТСТВЕННОГО СООБЩЕНИЯ НА ДИСПЛЕЕ -----
  // Проверяем, находится ли дисплей в нормальном режиме
  if (currentDisplayMode == DISPLAY_NORMAL) {
    // Очищаем экран дисплея
    lcd->clear();
    
    // Устанавливаем курсор в начало первой строки
    lcd->setCursor(0, 0);
    
    // Печатаем название системы
    lcd->print("Smart Greenhouse");
    
    // Переходим на вторую строку
    lcd->setCursor(0, 1);
    
    // Печатаем статус
    lcd->print("System Ready");
    
    // Показываем сообщение 2 секунды
    delay(2000);
  }
  
  // ----- ШАГ 14: ИНИЦИАЛИЗАЦИЯ ТАЙМЕРОВ -----
  // Запоминаем текущее время для смены экрана
  lastDisplayChange = millis();
  
  // Запоминаем время успешной работы дисплея
  lastDisplaySuccess = millis();
  
  // Инициализируем время последнего полива
  lastWatering = millis();
  
  // Выводим финальное сообщение
  Serial.println("\n=== SYSTEM READY ===");
  
  // Пауза 2 секунды для чтения сообщений
  delay(2000);
  
  // Очищаем экран перед началом работы
  if (currentDisplayMode == DISPLAY_NORMAL) {
    lcd->clear();
  }
}

// ================================================
// РАЗДЕЛ 12: ЧТЕНИЕ ВСЕХ ДАТЧИКОВ
// ================================================

// Функция для чтения всех датчиков
void readSensors() {
  // ===== 1. ИСПРАВЛЕННОЕ ЧТЕНИЕ ДАТЧИКА DHT11 С ЗАДЕРЖКОЙ =====
  #if ENABLE_DHT
  // Статическая переменная для хранения времени последнего чтения
  static unsigned long lastDHTReadTime = 0;

  // Получаем текущее время в миллисекундах
  unsigned long currentTime = millis();

  // ВАЖНО: DHT11 требует минимум 2 СЕКУНДЫ между чтениями!
  // Если читать чаще - он будет возвращать старые значения
  const unsigned long DHT_MIN_INTERVAL = 2000;  // 2000 мс = 2 секунды

  // Проверяем, прошло ли достаточно времени с последнего чтения
  if (currentTime - lastDHTReadTime >= DHT_MIN_INTERVAL) {
    // Обновляем время последнего чтения
    lastDHTReadTime = currentTime;
    
    // ДИАГНОСТИКА: Выводим сколько времени прошло
    unsigned long timeSinceLastRead = currentTime - (lastDHTReadTime - DHT_MIN_INTERVAL);
    Serial.print("DHT11: Reading after ");
    Serial.print(timeSinceLastRead);
    Serial.println(" ms");
    
    // ----- ШАГ 1: ЧИТАЕМ ДАТЧИК -----
    // Вызываем метод readTemperature() для чтения температуры
    float tempRaw = dht.readTemperature();
    
    // Вызываем метод readHumidity() для чтения влажности
    float humidityRaw = dht.readHumidity();
    
    // ----- ШАГ 2: ПРОВЕРЯЕМ НА ОШИБКИ -----
    // Проверяем, не вернул ли датчик ошибку (NaN - Not a Number)
    if (isnan(tempRaw) || isnan(humidityRaw)) {
        // Если ошибка чтения
        Serial.println("DHT11: READ ERROR - Sensor not responding!");
        
        // Увеличиваем счетчик ошибок
        dhtErrorCount++;
        
        // Если ошибок слишком много
        if (dhtErrorCount > MAX_DHT_ERRORS) {
            Serial.println("DHT11: Too many errors!");
        }
        
        // Не обновляем фильтрованные значения при ошибке
        return;  // Выходим из функции
    }
    
    // ----- ШАГ 3: ВЫВОД СЫРЫХ ЗНАЧЕНИЙ -----
    // Всегда выводим сырые значения для диагностики
    Serial.print("DHT11: RAW VALUES - Temp=");
    Serial.print(tempRaw);
    Serial.print("C, Humidity=");
    Serial.print(humidityRaw);
    Serial.println("%");
    
    // ----- ШАГ 4: ПРОВЕРКА НА НЕИЗМЕННЫЕ ЗНАЧЕНИЯ -----
    // DHT11 иногда "залипает" на значениях
    // Сохраняем предыдущие значения для сравнения
    static float prevTemp = 25.0;
    static float prevHumidity = 60.0;
    static int sameValueCount = 0;
    
    // Проверяем, изменились ли значения
    // Используем небольшую дельту для учета погрешности
    float tempDelta = abs(tempRaw - prevTemp);
    float humidityDelta = abs(humidityRaw - prevHumidity);
    
    if (tempDelta < 0.1 && humidityDelta < 0.1) {
        // Значения почти не изменились
        sameValueCount++;
        Serial.print("DHT11: Values not changing! Count=");
        Serial.println(sameValueCount);
        
        // Если значения не менялись 5 раз подряд (15 секунд)
        if (sameValueCount >= 5) {
            Serial.println("DHT11: HARD RESET ATTEMPT...");
            
            // Жесткий сброс: переинициализируем датчик
            // Отключаем датчик
            // Примечание: библиотека DHT не имеет метода end(),
            // поэтому создаем новый объект
            
            // Создаем новый объект DHT
            dht = DHT(DHT_PIN, DHT11);
            
            // Ждем 100 мс
            delay(100);
            
            // Инициализируем заново
            dht.begin();
            
            // Ждем 2 секунды для стабилизации
            delay(2000);
            
            // Сбрасываем счетчик
            sameValueCount = 0;
            
            // Не обновляем значения после сброса
            // Подождем следующего цикла
            return;
        }
      } else {
        // Значения изменились - сбрасываем счетчик
        if (sameValueCount > 0) {
            Serial.println("DHT11: Values changed - sensor OK");
            sameValueCount = 0;
        }
        
        // Сохраняем текущие значения как предыдущие
        prevTemp = tempRaw;
        prevHumidity = humidityRaw;
        
        // Сбрасываем счетчик ошибок
        dhtErrorCount = 0;
      }
    
      // ----- ШАГ 5: ПРИМЕНЯЕМ ФИЛЬТРАЦИЮ -----
      // Только если значения валидны и изменились
      tempFiltered = applyFilter(tempFiltered, tempRaw, 0.3);
      humidityFiltered = applyFilter(humidityFiltered, humidityRaw, 0.3);
    
      // ----- ШАГ 6: ВЫВОД ОТФИЛЬТРОВАННЫХ ЗНАЧЕНИЙ -----
      Serial.print("DHT11: FILTERED - Temp=");
      Serial.print(tempFiltered);
      Serial.print("C, Humidity=");
      Serial.print(humidityFiltered);
      Serial.println("%");
    
  } else {
      // Еще не прошло 2 секунды - пропускаем чтение
      // Это нормально, DHT11 медленный датчик
      static unsigned long lastSkipMessage = 0;
      if (currentTime - lastSkipMessage > 10000) {  // Сообщение раз в 10 секунд
        lastSkipMessage = currentTime;
        Serial.println("DHT11: Waiting 2 seconds between readings...");
      }
  }
  #endif  // Конец блока #if ENABLE_DHT
  
  
  // 2. ЧТЕНИЕ ВЛАЖНОСТИ ПОЧВЫ
  #if ENABLE_SOIL
  // Получаем стабильное значение датчика почвы с помощью функции readSoilMoistureStable()
  // Функция возвращает "сырое" значение от 0 до 1023
  int soilRaw = readSoilMoistureStable();
  
  // Преобразуем "сырое" значение (0-1023) в проценты (0-100%)
  // Используем функцию map() для линейного преобразования
  // map(значение, от_мин, от_макс, к_мин, к_макс)
  // SOIL_DRY_CALIB (620) → 0%
  // SOIL_WET_CALIB (310) → 100%
  int soilPercent = map(soilRaw, SOIL_DRY_CALIB, SOIL_WET_CALIB, 0, 100);
  
  // Ограничиваем значение между 0 и 100%
  // Используем функцию constrain(значение, минимум, максимум)
  soilPercent = constrain(soilPercent, 0, 100);
  
  // Применяем фильтр сглаживания (медленнее для почвы)
  // Используем коэффициент 0.15 вместо 0.3 (FILTER_COEFF * 0.5)
  // Почва медленно сохнет/намокает, поэтому нужен более плавный фильтр
  soilMoistureFiltered = applyFilter((float)soilMoistureFiltered, (float)soilPercent, FILTER_COEFF * 0.5);
  #else
  // Если датчик почвы отключен
  // Используем тестовое значение 50% (средняя влажность)
  soilMoistureFiltered = 50;
  #endif
  
  // 3. ЧТЕНИЕ ОСВЕЩЕННОСТИ
  #if ENABLE_LIGHT
  // Получаем усредненное значение датчика освещенности
  // Используем универсальную функцию readAnalogSensorStable()
  int lightRaw = readAnalogSensorStable(LIGHT_SENSOR_PIN);
  
  // Преобразуем в проценты (инвертированное преобразование)
  // Ваш датчик инвертированный: темно -> большое значение
  // Поэтому преобразуем от 100% к 0%
  // DARK_VALUE (0) → 100%
  // BRIGHT_VALUE (675) → 0%
  int lightPercent = map(lightRaw, DARK_VALUE, BRIGHT_VALUE, 100, 0);
  
  // Ограничиваем значение 0-100%
  lightPercent = constrain(lightPercent, 0, 100);
  
  // Применяем фильтр сглаживания
  lightLevelFiltered = applyFilter((float)lightLevelFiltered, (float)lightPercent, FILTER_COEFF);
  #else
  // Если датчик освещенности отключен
  // Используем тестовое значение 50% (средняя освещенность)
  lightLevelFiltered = 50;
  #endif
  
  // 4. ЧТЕНИЕ БИНАРНОГО ДАТЧИКА ВОДЫ (САМАЯ ВАЖНАЯ ЧАСТЬ!)
  #if ENABLE_WATER
  // Читаем состояние датчика воды с помощью функции readBinaryWaterSensor()
  // Функция возвращает true если вода есть, false если воды нет
  // Результат сохраняется в глобальную переменную waterPresent
  waterPresent = readWaterSensorProtected();  // Используем защищенную функцию
  
  // Для отладки: периодически выводим состояние воды в Serial монитор
  // Создаем статическую переменную для хранения времени последнего вывода
  // static означает, что переменная сохраняет значение между вызовами функции
  static unsigned long lastWaterDebug = 0;
  
  // Проверяем, прошло ли 10 секунд (10000 мс) с последнего вывода
  if (millis() - lastWaterDebug > 10000) {
    // Обновляем время последнего вывода
    lastWaterDebug = millis();
    
    // Читаем сырое значение датчика воды для отладки
    int rawValue = analogRead(WATER_LEVEL_PIN);
    
    // Выводим информацию в Serial монитор
    Serial.print("Water sensor: raw=");
    Serial.print(rawValue);
    Serial.print(", threshold=");
    Serial.print(WATER_SENSOR_THRESHOLD);
    Serial.print(", water present=");
    
    // Используем тернарный оператор для вывода YES или NO
    // waterPresent ? "YES" : "NO" означает:
    // если waterPresent = true, то "YES", иначе "NO"
    Serial.println(waterPresent ? "YES" : "NO");
    
    // Дополнительная информация для отладки
    if (WATER_SENSOR_INVERTED) {
      Serial.println("  Logic: standard (LOW in water)");
    } else {
      Serial.println("  Logic: YOUR sensor (HIGH in water)");
    }
  }
  #else
  // Если датчик воды отключен в настройках (ENABLE_WATER = false)
  // Считаем что вода есть (для тестирования)
  waterPresent = true;
  #endif
}

// ================================================
// РАЗДЕЛ 13: УПРАВЛЕНИЕ ВЕНТИЛЯЦИЕЙ (ФОРТОЧКОЙ)
// ================================================

// Функция для управления форточкой на основе температуры
// Параметр: temperature - текущая температура воздуха
void controlWindow(float temperature) {
  // Проверка на ошибку датчика температуры
  // isnan() проверяет, является ли значение "не числом" (NaN)
  if (isnan(temperature)) {
    // Если температура некорректна - выводим сообщение об ошибке
    Serial.println("ERROR: Temperature sensor returned invalid value");
    
    // Выходим из функции (не выполняем дальнейший код)
    return;
  }
  
  // УСЛОВИЕ 1: ОТКРЫТЬ ФОРТОЧКУ
  // Проверяем два условия с помощью оператора && (И):
  // 1. temperature >= OPEN_TEMP (температура >= 28°C)
  // 2. !windowIsOpen (форточка закрыта, ! означает "НЕ")
  if (temperature >= OPEN_TEMP && !windowIsOpen) {
    // Оба условия выполнены - открываем форточку
    
    // Команда сервоприводу: повернуться на угол SERVO_OPEN (90°)
    ventServo.write(SERVO_OPEN);
    
    // Запоминаем текущий угол
    ventAngle = SERVO_OPEN;
    
    // Устанавливаем флаг "открыта" в true
    windowIsOpen = true;
    
    // Логирование в Serial монитор
    Serial.print("VENTILATION: Opening window at ");
    Serial.print(temperature);
    Serial.println("C (too hot)");
    
    // Вывод сообщения на дисплей
    // Проверяем, находится ли дисплей в нормальном режиме
    if (currentDisplayMode == DISPLAY_NORMAL) {
      // Очищаем экран
      lcd->clear();
      
      // Печатаем сообщение на первой строке
      safePrint("TEMPERATURE HIGH", 0, 0);
      
      // Печатаем сообщение на второй строке
      safePrint("OPENING WINDOW", 0, 1);
      
      // Показываем сообщение 1 секунду
      delay(1000);
    }
  } 
  
  // УСЛОВИЕ 2: ЗАКРЫТЬ ФОРТОЧКУ
  // Проверяем два условия:
  // 1. temperature <= CLOSE_TEMP (температура <= 26°C)
  // 2. windowIsOpen (форточка открыта)
  else if (temperature <= CLOSE_TEMP && windowIsOpen) {
    // Оба условия выполнены - закрываем форточку
    
    // Команда сервоприводу: вернуться в угол SERVO_CLOSED (0°)
    ventServo.write(SERVO_CLOSED);
    
    // Запоминаем текущий угол
    ventAngle = SERVO_CLOSED;
    
    // Сбрасываем флаг "открыта" в false
    windowIsOpen = false;
    
    // Логирование в Serial монитор
    Serial.print("VENTILATION: Closing window at ");
    Serial.print(temperature);
    Serial.println("C (normal temp)");
    
    // Вывод сообщения на дисплей
    if (currentDisplayMode == DISPLAY_NORMAL) {
      lcd->clear();
      safePrint("TEMPERATURE OK", 0, 0);
      safePrint("CLOSING WINDOW", 0, 1);
      delay(1000);
    }
  }
  
  // Если температура между 26°C и 28°C - ничего не делаем
  // Форточка остается в текущем положении
  // Это предотвращает "дергание" при температуре около порога
}

// ================================================
// РАЗДЕЛ 14: УПРАВЛЕНИЕ ВСЕМИ СИСТЕМАМИ ТЕПЛИЦЫ
// ================================================

// Функция для управления всеми системами теплицы
void controlSystems() {
  // Получаем текущее время в миллисекундах
  unsigned long currentTime = millis();
  
// ===== 1. УПРАВЛЕНИЕ ПОЛИВОМ (10 СЕКУНД + 5 МИНУТ ОЖИДАНИЯ) =====
  
  // Проверяем, работает ли насос в данный момент
  if (pumpState) {
    // НАСОС ВКЛЮЧЕН - проверяем условия для выключения
    
    // Условие 1: насос работает больше 10 секунд
    bool timeCondition = (currentTime - pumpStartTime > PUMP_RUN_TIME);
    
    // Условие 2: вода закончилась в баке (аварийное отключение)
    // ВРЕМЕННО ОТКЛЮЧЕНО: датчик воды еще не подключен
    // bool noWaterCondition = (!waterPresent);
    
    // Проверяем, выполняется ли условие (только по времени)
    // if (timeCondition || noWaterCondition) {
    if (timeCondition) {  // <-- ИСПРАВЛЕНО: только проверка времени
      // Выключаем насос
      digitalWrite(PUMP_PIN, LOW);
      pumpState = false;
      lastWatering = currentTime;  // Обновляем время последнего полива
      
      // Логирование причины выключения
      // if (noWaterCondition) {
      //   Serial.println("WATERING: Emergency stop - NO WATER in tank!");
      // } else if (timeCondition) {
      //   Serial.println("WATERING: Stopping pump - 10 seconds elapsed");
      //   Serial.println("WATERING: Now waiting 5 minutes for water absorption");
      // }
      
      // Упрощенное логирование
      Serial.println("WATERING: Stopping pump - 5 seconds elapsed");
      Serial.println("WATERING: Now waiting 5 minutes for water absorption");
    }
    
  } else {
    // НАСОС ВЫКЛЮЧЕН - проверяем условия для включения
    
    // УСЛОВИЯ ДЛЯ ВКЛЮЧЕНИЯ НАСОСА:
    // 1. Влажность почвы < 20% (почва сухая)
    // 2. В баке ЕСТЬ вода - ВРЕМЕННО ОТКЛЮЧЕНО (датчик не подключен)
    // 3. Прошло минимум 5 минут с последнего полива
    
    bool soilDryCondition = (soilMoistureFiltered < SOIL_DRY);
    // bool waterPresentCondition = waterPresent;  // <-- ЗАКОММЕНТИРОВАНО
    bool cooldownCondition = (currentTime - lastWatering > WATERING_COOLDOWN);
    
    // Проверяем условия (без проверки воды)
    // if (soilDryCondition && waterPresentCondition && cooldownCondition) {
    if (soilDryCondition && cooldownCondition) {  // <-- ИСПРАВЛЕНО: только 2 условия
      // Все условия выполнены - ВКЛЮЧАЕМ НАСОС НА 10 СЕКУНД
      digitalWrite(PUMP_PIN, HIGH);
      pumpState = true;
      pumpStartTime = currentTime;
      
      // Вывод сообщения на дисплей
      if (currentDisplayMode == DISPLAY_NORMAL) {
        lcd->clear();
        safePrint("AUTO WATERING", 0, 0);
        safePrint("5 SECONDS", 0, 1);
        delay(1000);
      }
      
      // Логирование
      Serial.print("WATERING: Starting pump for 5 seconds (soil=");
      Serial.print(soilMoistureFiltered);
      Serial.println("%)");
      Serial.print("WATERING: Last watering was ");
      Serial.print((currentTime - lastWatering) / 1000);
      Serial.println(" seconds ago");
    }
    // else if (soilDryCondition && waterPresentCondition && !cooldownCondition) {
    else if (soilDryCondition && !cooldownCondition) {  // <-- ИСПРАВЛЕНО: без проверки воды
      // Почва сухая, но еще не прошло 5 минут
      // Выводим информацию о времени ожидания (раз в 30 секунд)
      static unsigned long lastCooldownMessage = 0;
      if (currentTime - lastCooldownMessage > 30000) {  // Каждые 30 секунд
        lastCooldownMessage = currentTime;
        
        // Вычисляем сколько секунд осталось ждать
        unsigned long secondsLeft = (WATERING_COOLDOWN - (currentTime - lastWatering)) / 1000;
        
        if (secondsLeft > 0) {
          Serial.print("WATERING: Soil is dry but waiting ");
          Serial.print(secondsLeft);
          Serial.println(" seconds before next watering");
          
          // Показать на дисплее время ожидания
          if (currentDisplayMode == DISPLAY_NORMAL && displayScreen == 3) {
            char waitStr[17];
            sprintf(waitStr, "Wait:%02d:%02d      ", 
                    (int)(secondsLeft / 60),  // Минуты
                    (int)(secondsLeft % 60)); // Секунды
            safePrint(waitStr, 0, 1);
          }
        }
      }
    }
  }
  
  // ===== 2. УПРАВЛЕНИЕ ОСВЕЩЕНИЕМ (без изменений) =====
  
  if (lightLevelFiltered < LIGHT_ON_THRESHOLD && !lampState) {
    // ВКЛЮЧАЕМ ФИТОЛЕНТУ
    if (RELAY_INVERTED) {
      digitalWrite(LED_GROW_PIN, LOW);   // Для инвертированного реле: LOW = ВКЛ
    } else {
      digitalWrite(LED_GROW_PIN, HIGH);  // Для обычного реле: HIGH = ВКЛ
    }
    lampState = true;
    Serial.print("LIGHTING: Turning ON grow light (light=");
    Serial.print(lightLevelFiltered);
    Serial.println("% < 30%)");
  } 
  else if (lightLevelFiltered > LIGHT_OFF_THRESHOLD && lampState) {
    // ВЫКЛЮЧАЕМ ФИТОЛЕНТУ
    if (RELAY_INVERTED) {
      digitalWrite(LED_GROW_PIN, HIGH);  // Для инвертированного реле: HIGH = ВЫКЛ
    } else {
      digitalWrite(LED_GROW_PIN, LOW);   // Для обычного реле: LOW = ВЫКЛ
    }
    lampState = false;
    Serial.print("LIGHTING: Turning OFF grow light (light=");
    Serial.print(lightLevelFiltered);
    Serial.println("% > 50%)");
  }
  
  // ===== 3. УПРАВЛЕНИЕ ВЕНТИЛЯЦИЕЙ (без изменений) =====
  controlWindow(tempFiltered);
}

// ================================================
// РАЗДЕЛ 15: ОБНОВЛЕНИЕ ИНФОРМАЦИИ НА ДИСПЛЕЕ
// ================================================

// Функция для обновления информации на дисплее
void updateDisplay() {
  // Если дисплей не в нормальном режиме - не обновляем
  if (currentDisplayMode != DISPLAY_NORMAL) {
    // Выходим из функции (не выполняем дальнейший код)
    return;
  }
  
  // Проверяем здоровье дисплея с помощью функции checkLCDHealth()
  if (!checkLCDHealth()) {
    // Если дисплей не отвечает (! означает "НЕ", так что !checkLCDHealth() = true если checkLCDHealth() вернул false)
    // Переходим в режим восстановления
    currentDisplayMode = DISPLAY_RECOVERING;
    
    // Выходим из функции
    return;
  }
  
  // Проверяем, прошло ли 3 секунды с последней смены экрана
  // millis() - текущее время в миллисекундах
  // lastDisplayChange - время последней смены экрана
  // DISPLAY_CHANGE_TIME = 3000 (3 секунды)
  if (millis() - lastDisplayChange > DISPLAY_CHANGE_TIME) {
    // Переключаем экран на следующий
    // displayScreen = (displayScreen + 1) % MAX_DISPLAY_SCREENS
    // % - оператор остатка от деления (модуль)
    // Пример: если displayScreen = 4, то (4+1)%5 = 5%5 = 0
    // Таким образом после 4-го экрана снова показывается 0-й
    displayScreen = (displayScreen + 1) % MAX_DISPLAY_SCREENS;
    
    // Запоминаем время смены экрана
    lastDisplayChange = millis();
    
    // Очищаем экран
    // Вместо lcd->clear() используем печать пробелов для большей стабильности
    safePrint("                ", 0, 0);  // 16 пробелов для первой строки
    safePrint("                ", 0, 1);  // 16 пробелов для второй строки
    
    // В зависимости от номера экрана показываем разную информацию
    // Используем оператор switch для выбора варианта
    switch(displayScreen) {
      case 0:  // ЭКРАН 0: ТЕМПЕРАТУРА И СОСТОЯНИЕ ФОРТОЧКИ
        // Печатаем текст "TEMP: " в позиции (0, 0)
        safePrint("TEMP: ", 0, 0);
        
        // Проверяем корректность температуры
        if (isnan(tempFiltered)) {
          // Если температура некорректна (NaN)
          safePrint("Error", 6, 0);
        } else {
          // Создаем массив символов для хранения строки температуры
          char tempStr[10];
          
          // Преобразуем float в string с помощью функции dtostrf()
          // Параметры: число, общая ширина, знаков после запятой, буфер
          dtostrf(tempFiltered, 5, 1, tempStr);
          
          // Печатаем температуру
          safePrint(tempStr, 6, 0);
          
          // Печатаем символ градуса ° (код 223 в ASCII)
          lcd->write(223);
          
          // Печатаем букву "C"
          safePrint("C", 12, 0);
        }
        
        // Вторая строка: состояние форточки
        if (tempFiltered >= OPEN_TEMP) {
          safePrint("WINDOW: OPEN", 0, 1);
        } else if (tempFiltered <= CLOSE_TEMP) {
          safePrint("WINDOW: CLOSED", 0, 1);
        } else {
          safePrint("WINDOW: OK", 0, 1);
        }
        break;
        
      case 1:  // ЭКРАН 1: ВЛАЖНОСТЬ ВОЗДУХА
        safePrint("AIR HUM: ", 0, 0);
        
        if (isnan(humidityFiltered)) {
          safePrint("Error", 9, 0);
        } else {
          char humStr[10];
          dtostrf(humidityFiltered, 5, 0, humStr);  // 0 знаков после запятой
          safePrint(humStr, 9, 0);
          safePrint("%", 14, 0);
        }
        
        // Текстовая оценка влажности
        if (humidityFiltered >= 80) {
          safePrint("STATUS: HUMID", 0, 1);
        } else if (humidityFiltered >= 60) {
          safePrint("STATUS: NORMAL", 0, 1);
        } else if (humidityFiltered >= 40) {
          safePrint("STATUS: DRY", 0, 1);
        } else {
          safePrint("STATUS: VERY DRY", 0, 1);
        }
        break;
        
      case 2:  // ЭКРАН 2: ОСВЕЩЕННОСТЬ И СОСТОЯНИЕ ФИТОЛЕНТЫ
        safePrint("LIGHT: ", 0, 0);
        
        // Создаем массив для строки освещенности
        char lightStr[10];
        
        // Преобразуем int в string с помощью функции itoa()
        // Параметры: число, буфер, система счисления (10 - десятичная)
        itoa(lightLevelFiltered, lightStr, 10);
        
        // Печатаем освещенность
        safePrint(lightStr, 7, 0);
        safePrint("%", 10, 0);
        
        // Вторая строка: состояние фитоленты
        safePrint("GROW LIGHT: ", 0, 1);
        
        // Используем тернарный оператор: условие ? если_да : если_нет
        // lampState ? "ON" : "OFF" - если lampState=true то "ON", иначе "OFF"
        safePrint(lampState ? "ON" : "OFF", 12, 1);
        break;
        
      case 3:  // ЭКРАН 3: ВЛАЖНОСТЬ ПОЧВЫ И СОСТОЯНИЕ НАСОСА
        safePrint("SOIL: ", 0, 0);
        
        char soilStr[10];
        itoa(soilMoistureFiltered, soilStr, 10);
        safePrint(soilStr, 6, 0);
        safePrint("%", 9, 0);
        
        safePrint("WATER PUMP: ", 0, 1);
        safePrint(pumpState ? "ON" : "OFF", 12, 1);
        break;
      
      case 4:  // ЭКРАН 4: УРОВЕНЬ ВОДЫ В БАКЕ (САМЫЙ ВАЖНЫЙ ЭКРАН!)
        safePrint("WATER: ", 0, 0);
        
        // Бинарный датчик: только FULL или EMPTY
        // Проверяем переменную waterPresent
        if (waterPresent) {
          // Если waterPresent = true - вода ЕСТЬ
          safePrint("FULL", 7, 0);
        } else {
          // Если waterPresent = false - воды НЕТ
          safePrint("EMPTY", 7, 0);
        }
        
        // Очищаем вторую строку пробелами
        safePrint("                ", 0, 1);
        
        // Показываем статус системы полива
        if (!waterPresent) {
          // Если воды НЕТ - показываем предупреждение
          safePrint("REFILL WATER!", 0, 1);
        } else if (soilMoistureFiltered < SOIL_DRY) {
          // Если вода есть и почва сухая - готов к поливу
          safePrint("READY TO WATER", 0, 1);
        } else {
          // Если вода есть и почва влажная - система в порядке
          safePrint("SYSTEM OK", 0, 1);
        }
        break;
    }
    
    // Обновляем время последней успешной работы дисплея
    lastDisplaySuccess = millis();
  }
}

// ================================================
// РАЗДЕЛ 16: ОТЛАДОЧНЫЙ ВЫВОД В СЕРИАЛЬНЫЙ МОНИТОР
// ================================================

// Функция для отладочного вывода в Serial монитор
void debugOutput() {
  // Создаем статическую переменную для хранения времени последнего вывода
  // static означает, что переменная сохраняет значение между вызовами функции
  static unsigned long lastDebug = 0;
  
  // Проверяем, прошло ли 5 секунд (5000 мс) с последнего вывода
  if (millis() - lastDebug > 5000) {
    // Обновляем время последнего вывода
    lastDebug = millis();
    
    // Выводим заголовок отчета
    Serial.println("\n=== GREENHOUSE STATUS REPORT ===");
    
    // Вывод показаний датчиков
    Serial.print("Temperature: "); 
    Serial.print(tempFiltered); 
    Serial.println(" °C");
    
    Serial.print("Air humidity: "); 
    Serial.print(humidityFiltered); 
    Serial.println(" %");
    
    Serial.print("Light level: "); 
    Serial.print(lightLevelFiltered); 
    Serial.println(" %");
    
    Serial.print("Soil moisture: "); 
    Serial.print(soilMoistureFiltered); 
    Serial.println(" %");
    
    // ОСОБЕННОСТЬ: Вывод состояния бинарного датчика воды
    Serial.print("Water tank: ");
    // Используем тернарный оператор для вывода текста
    Serial.println(waterPresent ? "FULL (water present)" : "EMPTY (no water)");
    
    // Вывод сырого значения датчика воды для отладки
    int waterRaw = analogRead(WATER_LEVEL_PIN);
    Serial.print("Water sensor raw value: ");
    Serial.print(waterRaw);
    
    // Дополнительная информация о логике датчика
    if (WATER_SENSOR_INVERTED) {
      Serial.print(" (standard sensor - LOW in water)");
    } else {
      Serial.print(" (YOUR sensor - HIGH in water)");
    }
    Serial.println();
    
    // Вывод состояний устройств
    Serial.print("Devices: ");
    Serial.print("Grow light "); 
    Serial.print(lampState ? "ON" : "OFF");
    Serial.print(", Water pump "); 
    Serial.print(pumpState ? "ON" : "OFF");
    Serial.print(", Window "); 
    Serial.println(windowIsOpen ? "OPEN" : "CLOSED");
    
    // Вывод информации о реле (для справки)
    Serial.print("Relay logic: ");
    Serial.println(RELAY_INVERTED ? "INVERTED (LOW=ON, HIGH=OFF)" : 
                                    "NORMAL (HIGH=ON, LOW=OFF)");
    
    // Вывод информации о состоянии дисплея
    Serial.print("Display health: ");
    if (currentDisplayMode == DISPLAY_NORMAL) {
      Serial.print("OK, ");
      Serial.print(displayRecoveryAttempts);
      Serial.println(" recovery attempts");
    } else if (currentDisplayMode == DISPLAY_RECOVERING) {
      Serial.println("RECOVERING");
    } else {
      Serial.println("DISCONNECTED");
    }
    
    // Вывод информации о времени работы насоса
    if (pumpState) {
      // Вычисляем время работы насоса в секундах
      unsigned long pumpRunTime = millis() - pumpStartTime;
      Serial.print("Pump running for: ");
      Serial.print(pumpRunTime / 1000);  // Деление на 1000 для перевода в секунды
      Serial.println(" seconds");
    }
    
    // Вывод разделительной линии
    Serial.println("==================================\n");
  }
}

// ================================================
// РАЗДЕЛ 17: ПРОВЕРКА УРОВНЯ ВОДЫ И ВЫВОД ПРЕДУПРЕЖДЕНИЙ
// ================================================
/*
// Функция для проверки уровня воды и вывода предупреждений
void checkWaterLevel() {
  // Проверяем, есть ли вода в баке
  // !waterPresent означает "НЕ waterPresent" (true если waterPresent = false)
  if (!waterPresent) {
    // Если воды НЕТ (!waterPresent = true)
    
    // Создаем статическую переменную для хранения времени последнего предупреждения
    static unsigned long lastWaterAlert = 0;
    
    // Проверяем, прошло ли 10 секунд (10000 мс) с последнего предупреждения
    if (millis() - lastWaterAlert > 10000) {
      // Обновляем время последнего предупреждения
      lastWaterAlert = millis();
      
      // Выводим предупреждение на дисплей
      if (currentDisplayMode == DISPLAY_NORMAL) {
        lcd->clear();
        safePrint("!!! WARNING !!!", 0, 0);
        safePrint("WATER TANK EMPTY", 0, 1);
        
        // Показываем дольше, так как это важное предупреждение
        // delay(2000) выполняется внутри safePrint, поэтому не нужно добавлять еще
      }
      
      // Мигаем светодиодом (сигнал тревоги)
      // Цикл for выполняется 3 раза
      for (int i = 0; i < 3; i++) {
        digitalWrite(STATUS_LED, HIGH);  // ВКЛЮЧИТЬ светодиод
        delay(300);                      // Держим 0.3 секунды
        digitalWrite(STATUS_LED, LOW);   // ВЫКЛЮЧИТЬ светодиод
        delay(300);                      // Пауза 0.3 секунды
      }
      
      // Логирование в Serial монитор
      Serial.println("WARNING: Water tank is EMPTY! Please refill immediately!");
    }
  } else {
    // Если вода ЕСТЬ (waterPresent = true)
    // Убедимся что светодиод выключен
    digitalWrite(STATUS_LED, LOW);
  }
}
*/

// ================================================
// РАЗДЕЛ 18: ГЛАВНЫЙ ЦИКЛ ПРОГРАММЫ (LOOP)
// ================================================

// Функция loop() выполняется БЕСКОНЕЧНО после setup()
void loop() {
  // ----- ШАГ 1: УПРАВЛЕНИЕ СОСТОЯНИЕМ ДИСПЛЕЯ -----
  
  // Проверяем, находится ли дисплей в нормальном режиме
  if (currentDisplayMode != DISPLAY_NORMAL) {
    // Если дисплей не в нормальном режиме - пытаемся восстановить
    attemptDisplayRecovery();
  } else {
    // Если в нормальном режиме - проверяем здоровье дисплея
    if (!checkLCDHealth()) {
      // Если дисплей не отвечает - переходим в режим восстановления
      currentDisplayMode = DISPLAY_RECOVERING;
    }
  }
  
  // ----- ШАГ 2: ЧТЕНИЕ ДАТЧИКОВ -----
  // Опрашиваем все датчики с помощью функции readSensors()
  readSensors();
  
  // ----- ШАГ 3: УПРАВЛЕНИЕ СИСТЕМАМИ -----
  // Управляем устройствами (полив, свет, вентиляция) с помощью функции controlSystems()
  controlSystems();
  
  // ----- ШАГ 4: ОБНОВЛЕНИЕ ДИСПЛЕЯ -----
  // Выводим данные на LCD дисплей с помощью функции updateDisplay()
  updateDisplay();
  
  // ----- ШАГ 5: ОТЛАДОЧНЫЙ ВЫВОД -----
  // Выводим статус в Serial монитор с помощью функции debugOutput()
  debugOutput();
  
  // ----- ШАГ 6: ПРОВЕРКА УРОВНЯ ВОДЫ -----
  // Проверяем уровень воды с помощью функции checkWaterLevel()
  //checkWaterLevel();
  
  // ----- ШАГ 7: АВТОМАТИЧЕСКИЙ РЕСЕТ ДИСПЛЕЯ (если включена защита) -----
  // Проверяем, включена ли супер-защита
  #if SUPER_PROTECTION
  // Создаем статическую переменную для хранения времени последней проверки
  static unsigned long lastAutoResetCheck = millis();
  
  // Проверяем каждые 30 секунд (30000 мс)
  if (millis() - lastAutoResetCheck > 30000) {
    // Обновляем время последней проверки
    lastAutoResetCheck = millis();
    
    // Проверяем, не обновлялся ли дисплей 25 секунд
    // lastDisplaySuccess - время последней успешной работы дисплея
    if (millis() - lastDisplaySuccess > 25000) {
      // Если дисплей не обновлялся 25+ секунд
      Serial.println("Авто-сброс: Дисплей не обновлялся 25+ секунд");
      
      // Мягкий сброс дисплея
      if (lcd != NULL) {
        lcd->noBacklight();  // Выключаем подсветку
        delay(100);
        lcd->backlight();    // Включаем подсветку
        delay(100);
      }
      
      // Возвращаемся к попыткам восстановления
      currentDisplayMode = DISPLAY_RECOVERING;
      
      // Сбрасываем счетчик попыток
      displayRecoveryAttempts = 0;
    }
  }

  
  #endif
  
  // ----- ШАГ 8: ПАУЗА ДЛЯ СТАБИЛЬНОЙ РАБОТЫ -----
  // Ждем 100 миллисекунд (0.1 секунды) перед следующим циклом
  delay(100);
  
  // Пауза нужна для:
  // 1. Стабильности работы системы
  // 2. Предотвращения перегрузки процессора
  // 3. Датчикам нужно время между измерениями
  // 4. Снижения энергопотребления
  // 5. Возможности отслеживать работу через Serial монитор
}

// ================================================
// КОНЕЦ ПРОГРАММЫ
// ================================================

/*
  КРАТКОЕ ОПИСАНИЕ КЛЮЧЕВЫХ НАСТРОЕК ДЛЯ ВАШЕЙ СИСТЕМЫ:
  
  1. ДАТЧИК ВОДЫ (работает наоборот):
     - WATER_SENSOR_INVERTED = false (правильно для вашего датчика)
     - Ваш датчик: HIGH в воде, LOW в воздухе
     - Логика: если значение > 500 → вода ЕСТЬ (возвращает true)
     - Порог можно менять: WATER_SENSOR_THRESHOLD = 500
  
  2. УПРАВЛЕНИЕ НАСОСОМ:
     - Насос включается только если ВСЕ условия выполнены:
       1. Влажность почвы < 20% (SOIL_DRY)
       2. Вода ЕСТЬ в баке (waterPresent = true)
       3. Прошло >10 минут с последнего полива (WATERING_INTERVAL)
       4. Прошло >1 минуты с последнего выключения (MIN_PUMP_OFF_TIME)
     - Насос выключается если ЛЮБОЕ условие выполнено:
       1. Влажность почвы > 60% (SOIL_WET)
       2. Насос работает >30 секунд (MAX_PUMP_RUN_TIME)
       3. Воды НЕТ в баке (waterPresent = false)
  
  3. РЕЛЕ (управление напряжением):
     - RELAY_INVERTED = true (скорее всего у вас такое)
     - Для инвертированного реле:
       - LOW (0В) на пине = устройство ВКЛЮЧЕНО
       - HIGH (5В) на пине = устройство ВЫКЛЮЧЕНО
  
  4. СИСТЕМА ВОССТАНОВЛЕНИЯ ДИСПЛЕЯ:
     - Если отключить провода от дисплея - система продолжит работать
     - При подключении проводов обратно - дисплей сам восстановится
     - 3 метода восстановления: мягкий сброс, переинициализация, сброс I2C
*/

/*
  ЧТО ДЕЛАТЬ ЕСЛИ НАСОС НЕ ВКЛЮЧАЕТСЯ:
  
  1. Откройте Serial монитор (скорость 9600)
  2. Посмотрите сообщения "Water sensor: raw=XXX, water present=YES/NO"
  3. Если water present=NO (хотя вода есть):
     - Проверьте сырое значение (raw)
     - Если raw < 500 (хотя датчик в воде) - уменьшите порог:
       const int WATER_SENSOR_THRESHOLD = 300;
     - Если raw > 500 (хотя датчик в воздухе) - увеличьте порог:
       const int WATER_SENSOR_THRESHOLD = 700;
  
  4. Если water present=YES, но насос не включается:
     - Посмотрите значение влажности почвы (Soil: XX%)
     - Если влажность > 20% - почва еще не сухая
     - Подождите пока почва высохнет или измените порог:
       const int SOIL_DRY = 30; // Вместо 20
  
  5. Проверьте остальные условия:
     - Прошло ли 10 минут с последнего полива?
     - Прошло ли 1 минута с последнего выключения?
*/

/*
  КАЛИБРОВКА ДАТЧИКОВ:
  
  1. ДАТЧИК ВОДЫ:
     - Поместите датчик в воду
     - Откройте Serial монитор
     - Увидите "Water sensor: raw=XXX"
     - Значение должно быть >500
     - Поместите датчик в воздух
     - Значение должно быть <500
     - Если значения близки к 500, измените порог
  
  2. ДАТЧИК ПОЧВЫ:
     - Поместите датчик в сухую почву
     - Запишите значение (должно быть около 620)
     - Поместите датчик в мокрую почву
     - Запишите значение (должно быть около 310)
     - Обновите константы:
       const int SOIL_DRY_CALIB = Ваше_значение_в_сухой_почве;
       const int SOIL_WET_CALIB = Ваше_значение_в_мокрой_почве;
  
  3. ДАТЧИК СВЕТА:
     - Затемните датчик полностью
     - Запишите значение (должно быть около 0)
     - Посветите ярким светом
     - Запишите значение (должно быть около 675)
     - Обновите константы:
       const int DARK_VALUE = Ваше_значение_в_темноте;
       const int BRIGHT_VALUE = Ваше_значение_при_ярком_свете;
*/